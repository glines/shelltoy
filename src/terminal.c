#include <assert.h>

#include "../extern/xkbcommon-keysyms.h"

#include "common/glError.h"

#include "terminal.h"

/* Internal data structure */
struct st_Terminal_Internal {
  st_ScreenRenderer screenRenderer;
  st_GlyphRenderer glyphRenderer;
};

/* Private methods */
void st_Terminal_tsmLogCallback(
    st_Terminal *self,
    const char *file,
    int line,
    const char *func,
    const char *subs,
    unsigned int sev,
    const char *format,
    va_list args);
void st_Terminal_tsmWriteCallback(
    struct tsm_vte *vte,
    const char *u8,
    size_t len,
    st_Terminal *self);
void st_Terminal_initWindow(st_Terminal *self);
void st_Terminal_initTSM(st_Terminal *self);
void st_Terminal_calculatePseudoTerminalSize(
    st_Terminal *self,
    int *ptyWidth,
    int *ptyHeight);

void st_Terminal_tsmLogCallback(
    st_Terminal *self,
    const char *file,
    int line,
    const char *func,
    const char *subs,
    unsigned int sev,
    const char *format,
    va_list args)
{
  /* TODO: Do something with this data */
  fprintf(stderr, "st_Terminal_tsmLogCallback() called\n");
}

void st_Terminal_tsmWriteCallback(
    struct tsm_vte *vte,
    const char *u8,
    size_t len,
    st_Terminal *self)
{
  int result;

  /* Write to the pseudo terminal */
  st_PTY_write(&self->pty, u8, len);
}

void st_Terminal_ptyReadCallback(
    st_Terminal *self,
    const char *u8,
    size_t len)
{
  /* Give the output from our child process to the vte */
  tsm_vte_input(
      self->vte,  /* vte */
      u8,  /* u8 */
      len  /* len */
      );
  /* Update the terminal screen display */
  st_Terminal_updateScreen(self);
}

void st_Terminal_initWindow(st_Terminal *self) {
  /* Create the SDL window */
  self->window = SDL_CreateWindow(
      "Shelltoy",  /* title */
      SDL_WINDOWPOS_UNDEFINED,  /* x */
      SDL_WINDOWPOS_UNDEFINED,  /* y */
      640,  /* w */
      480,  /* w */
      SDL_WINDOW_OPENGL
      | SDL_WINDOW_RESIZABLE  /* flags */
      );
  if (self->window == NULL) {
    fprintf(stderr, "Failed to create SDL window: %s\n",
        SDL_GetError());
    /* TODO: Fail gracefully */
    assert(0);
  }
  /* Store the window dimensions */
  self->width = 640;
  self->height = 480;

  /* The terminal emulator recieves all text through the operating system's IME
   * interface. See: <https://wiki.libsdl.org/Tutorials/TextInput> */
  SDL_StartTextInput();

  /* Create an OpenGL context for our window */
  self->glContext = SDL_GL_CreateContext(self->window);
  if (self->glContext == NULL) {
    fprintf(stderr, "Failed to initialize OpenGL context: %s\n",
        SDL_GetError());
    exit(EXIT_FAILURE);
  }
  /* Initialize GL entry points */
  glewExperimental = 1;
  GLenum error = glewInit();
  if (error != GLEW_OK) {
    fprintf(stderr, "Failed to initialize GLEW: %s\n",
        glewGetErrorString(error));
    exit(EXIT_FAILURE);
  }
  /* Swallow the error generated by GLEW. See:
   * <http://stackoverflow.com/a/20035078> */
  /* TODO: Suppress the message generated by swallowing this error */
  FORCE_CHECK_GL_ERROR();

  /* Configure the GL */
  glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
  FORCE_ASSERT_GL_ERROR();
  glClearDepth(1.0);
  FORCE_ASSERT_GL_ERROR();
  glEnable(GL_DEPTH_TEST);
  FORCE_ASSERT_GL_ERROR();
  glDepthFunc(GL_LESS);
  FORCE_ASSERT_GL_ERROR();
  glDisable(GL_CULL_FACE);  /* XXX */
  FORCE_ASSERT_GL_ERROR();
  glFrontFace(GL_CCW);
  FORCE_ASSERT_GL_ERROR();
  /* TODO: Calculate the window width and height */
  glViewport(0, 0, 640, 480);
  FORCE_ASSERT_GL_ERROR();
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  FORCE_ASSERT_GL_ERROR();
  SDL_GL_SwapWindow(self->window);
}

void st_Terminal_initTSM(st_Terminal *self) {
  /* Initialize the screen and state machine provided by libtsm */
  tsm_screen_new(
      &self->screen,  /* out */
      (tsm_log_t)st_Terminal_tsmLogCallback,  /* log */
      self  /* log_data */
      );
  tsm_vte_new(
      &self->vte,  /* out */
      self->screen,  /* con */
      (tsm_vte_write_cb)st_Terminal_tsmWriteCallback,  /* write_cb */
      self,  /* data */
      (tsm_log_t)st_Terminal_tsmLogCallback,  /* log */
      self  /* log_data */
      );
}

void st_Terminal_calculatePseudoTerminalSize(
    st_Terminal *self,
    int *ptyWidth,
    int *ptyHeight)
{
  int cellWidth, cellHeight;
  st_GlyphRenderer_getCellSize(&self->internal->glyphRenderer,
      &cellWidth,  /* width */
      &cellHeight  /* height */
      );
  /* TODO: The pseudo terminal size is the number of (halfwidth) glyph cells
   * that will fit in the terminal window */
  *ptyWidth = self->width / cellWidth;
  *ptyHeight = self->height / cellHeight;
}

/* TODO: Allow the user to configure the shell command to invoke */
#define ENV_PATH "/usr/bin/env"
#define SHELL "bash"

void st_Terminal_init(st_Terminal *self) {
  size_t len;
  /* Allocate memory for internal data structures */
  self->internal = (struct st_Terminal_Internal *)malloc(
      sizeof(struct st_Terminal_Internal));
  /* Initialize the SDL window */
  st_Terminal_initWindow(self);
  /* Initialize the glyph renderer */
  st_GlyphRenderer_init(&self->internal->glyphRenderer);
  /* Initialize the screen renderer */
  st_ScreenRenderer_init(&self->internal->screenRenderer,
      &self->internal->glyphRenderer  /* glyphRenderer */
      );
  /* Initialize the terminal state machine */
  st_Terminal_initTSM(self);
  /* Initialize the pseudo terminal and corresponding child process */
  st_PTY_init(&self->pty);
  char **argv = (char **)malloc(3 * sizeof(char *));
#define COPY_STRING(dst,src) \
  len = strlen(src); \
  dst = (char*)malloc(len + 1); \
  strncpy(dst, src, len); \
  dst[len] = '\0';
  COPY_STRING(argv[0], ENV_PATH);
  COPY_STRING(argv[1], SHELL);
  argv[2] = NULL;
  /* TODO: Construct a st_MonospaceFont object that combines multiple font
   * faces into one font that supports normal, bold, and wide glyphs */
  /* TODO: Calculate terminal width and height */
  st_PTY_startChild(&self->pty,
      "/usr/bin/env",  /* path */
      argv,  /* argv */
      (st_PTY_readCallback_t)st_Terminal_ptyReadCallback,  /* callback */
      self,  /* callback_data */
      80,  /* width */
      24  /* height */
      );
  /* FIXME: Is it safe to free argv at this point? */
  free(argv[0]);
  free(argv[1]);
  free(argv);
  /* TODO: Start sending input from the child process to tsm_vte_input()? */
  /* TODO: Start sending keyboard input to tsm_vte_handle_keyboard()? */
}

void st_Terminal_destroy(st_Terminal *self) {
  st_ScreenRenderer_destroy(&self->internal->screenRenderer);
  /* FIXME: Destroy the libtsm state machine */
  /* FIXME: Destroy the libtsm screen */
  st_PTY_destroy(&self->pty);
  /* Release memory for internal data structures */
  free(self->internal);
}

void st_Terminal_windowSizeChanged(
    st_Terminal *self,
    int width,
    int height)
{
  int ptyWidth, ptyHeight;
  /* Store the new window width and height */
  self->width = width;
  self->height = height;
  fprintf(stderr, "new window dimensions: %dx%d\n", width, height);
  /* Change the pseudo terminal screen size */
  st_Terminal_calculatePseudoTerminalSize(self, &ptyWidth, &ptyHeight);
  st_PTY_resize(&self->pty,
      ptyWidth,  /* width */
      ptyHeight  /* height */
      );
  /* Update the GL viewport size */
  glViewport(0, 0, width, height);
  FORCE_ASSERT_GL_ERROR();
  /* Re-draw the screen */
  st_Terminal_draw(self);
  SDL_GL_SwapWindow(self->window);
}

void st_Terminal_updateScreen(st_Terminal *self) {
  /* TODO: The update should probably be queued as an event... maybe? */
  /* TODO: Read the character grid from the libtsm screen */
  /* TODO: Make sure we have loaded all of the glyphs that we need */
  /* TODO: Make sure the changes get rendered immediately (might be useful to
   * render even sooner than the toy can render) */
  st_ScreenRenderer_updateScreen(&self->internal->screenRenderer,
      self->screen,  /* screen */
      &self->internal->glyphRenderer  /* glyphRenderer */
      );
}

void st_Terminal_draw(st_Terminal *self) {
  /* Clear the screen */
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  FORCE_ASSERT_GL_ERROR();

  /* TODO: Draw the background */

  /* Draw the glyphs on the screen */
  st_ScreenRenderer_draw(&self->internal->screenRenderer,
      &self->internal->glyphRenderer,  /* glyphRenderer */
      self->width,  /* viewportWidth */
      self->height  /* viewportHeight */
      );

  SDL_GL_SwapWindow(self->window);
}

void st_Terminal_textInput(
    st_Terminal *self,
    const char *text)
{
  uint32_t character;
  int result;

  fprintf(stderr, "SDL text input: '%s'\n", text);

  /* FIXME: Convert the text from UTF-8 to UTF-32 (properly) */

  /* Iterate over the input text to generate corresponding keyboard events */
  for (int i = 0; text[i] != '\0'; ++i) {
    character = (uint32_t)text[i];
    /* FIXME: It's not clear what each of the arguments for
     * tsm_vte_handle_keyboard() need to be set to. In particular, we don't
     * actually have a keysym here. */
    result = tsm_vte_handle_keyboard(
        self->vte,  /* vte */
        character,  /* keysym */
        0,  /* ascii */
        0,  /* mods */
        character  /* unicode */
        );
    if (result) {
      /* FIXME: It's not clear what result signifies or what
       * tsm_screen_sb_reset() actually does. */
      tsm_screen_sb_reset(self->screen);
    }
  }
}
void st_Terminal_keyInput(
    st_Terminal *self,
    SDL_Keycode keycode,
    uint16_t modifiers)
{
  unsigned int modifiers_tsm;
  uint32_t key_xkb;
  int result;

  /* TODO: Convert the SDL modifier flags to libtsm modifier flags */
  modifiers_tsm = 0;
  if (modifiers & KMOD_CAPS)
    modifiers_tsm |= TSM_LOCK_MASK;
  if (modifiers & KMOD_CTRL)
    modifiers_tsm |= TSM_CONTROL_MASK;
  if (modifiers & KMOD_SHIFT)
    modifiers_tsm |= TSM_SHIFT_MASK;
  if (modifiers & KMOD_ALT)
    modifiers_tsm |= TSM_ALT_MASK;
  if (modifiers & KMOD_GUI)
    modifiers_tsm |= TSM_LOGO_MASK;

  /* TODO: Handle shift+pgup events to scroll through back buffer */

  /* TODO: Convert SDL keys to XKB keys */
  switch (keycode) {
    case SDLK_BACKSPACE:
      key_xkb = XKB_KEY_BackSpace;
      break;
    case SDLK_RETURN:
      key_xkb = XKB_KEY_Return;
      break;
    default:
      return;
  }

  /* Send the key to the vte state machine */
  result = tsm_vte_handle_keyboard(
      self->vte,  /* vte */
      key_xkb,  /* keysym */
      XKB_KEY_NoSymbol,  /* ascii */
      modifiers_tsm,  /* mods */
      0  /* unicode */
      );
  if (result) {
    /* FIXME: It's not clear what result signifies or what
     * tsm_screen_sb_reset() actually does. */
    tsm_screen_sb_reset(self->screen);
  }
}
